Veuillez trouver ci-dessous les informations concernant l'utilisation de `chcp` et l'encodage recommandé pour l'écriture des scripts shell (`sh` ou `tcsh`), basées sur les sources fournies (dans le contexte de z/OS UNIX).

### Rôle de la commande `chcp`

La commande `chcp` est utilisée pour **définir, réinitialiser ou interroger la conversion de page de code ASCII/EBCDIC** actuellement en vigueur pour le terminal de contrôle.

*   **Interrogation :** L'option `-q` de `chcp` permet d'interroger les pages de code ASCII et EBCDIC actuelles utilisées pour ce terminal, et les résultats sont écrits sur la sortie standard.
    *   Par défaut (si la conversion n'a pas été modifiée), la page de code ASCII par défaut est **ISO8859-1**, et la page de code EBCDIC par défaut est **IBM-1047**.
*   **Conversion Terminal/Shell :** Lorsque vous utilisez des interfaces comme `rlogin` ou `telnet` pour accéder au shell, les données que vous entrez sont converties par défaut de l'ASCII (**ISO8859-1**) vers l'EBCDIC (**IBM-1047**) avant que le shell ne les traite. La commande `chcp` permet de modifier ces pages de code pour la session en cours.
*   **Restriction OMVS :** Il ne faut **pas utiliser `chcp` si vous êtes connecté via la commande TSO/E `OMVS`**. Les scripts shell peuvent vérifier la variable d'environnement `_BPX_TERMPATH` (qui vaut `"OMVS"` dans ce cas) pour contourner l'exécution de `chcp` si l'utilisateur est connecté via `OMVS`.

### Encodage Recommandé pour les Scripts Shell

La question de savoir si un script doit être écrit en ASCII ou en EBCDIC dépend entièrement de l'environnement d'exécution (*locale*).

La **règle fondamentale est que la page de code dans laquelle un script shell est encodé doit correspondre à la page de code du *locale* dans lequel il est exécuté**.

#### 1. Le Locale Détermine l'Encodage

*   Si un script est utilisé par plusieurs utilisateurs opérant dans différents *locales* (qui utilisent des pages de code différentes), **plusieurs copies du script shell** sont nécessaires, une pour chaque page de code de *locale* différente.
*   Si vous devez convertir un script shell d'une page de code à une autre (par exemple, pour le partager entre *locales* non compatibles IBM-1047), vous pouvez utiliser la commande `iconv`.
*   Par défaut, **le shell z/OS UNIX et ses utilitaires sont configurés comme des programmes EBCDIC**.

#### 2. Cas du `Locale` EBCDIC par défaut

*   Le *locale* par défaut pour le shell et les utilitaires est `C`.
*   Le système z/OS UNIX fonctionne par défaut dans le *locale* POSIX (également connu sous le nom de *locale* C) en utilisant la page de code **IBM-1047 (EBCDIC Latin-1)**.
*   Par conséquent, si le script doit s'exécuter dans le *locale* EBCDIC par défaut (IBM-1047), il doit être encodé en **IBM-1047**.

#### 3. Restrictions de Conversion Automatique (SBCS)

Si les scripts shell sont **étiquetés (*tagged*)** et que la **conversion automatique est activée** (`AUTOCVT(ON)`), le *locale* doit indiquer une **page de code SBCS (Single-Byte Character Set)**, et le script lui-même doit être encodé en SBCS.

#### 4. Utilisation de l'ASCII (ISO8859-1)

Il est possible d'utiliser des scripts ou fichiers source **encodés en ASCII (ISO8859-1)**, mais ils doivent être correctement étiquetés (*tagged*) pour permettre la conversion automatique par le système.

*   Si vous copiez des fichiers à distance depuis une plateforme ASCII vers z/OS, la commande `sftp` convertit généralement chaque fichier d'ASCII à EBCDIC lors de la copie, rendant l'étiquetage inutile dans ce cas.
*   Les programmes C peuvent être compilés en ASCII (ce qui les rend compatibles avec les *locales* ASCII), mais le shell lui-même reste EBCDIC.

En conclusion, dans l'environnement z/OS UNIX, l'**encodage EBCDIC (IBM-1047)** est l'encodage par défaut utilisé par le shell et est l'encodage le plus compatible avec l'environnement système de base. Cependant, le critère déterminant est que **l'encodage du script doit correspondre au *locale* défini pour la session où il est exécuté**.













#!/bin/bash

# --- PARAMÈTRES ---
# Définir l'extension des fichiers COPY (par exemple, .cpy, .cbl, ou rien si le nom est juste le membre)
COPY_EXTENSION="" 
# Si vos fichiers COPY sont nommés "MONCOPY.cpy", utilisez : COPY_EXTENSION=".cpy"

# Le répertoire contenant les fichiers COPY (le répertoire courant dans cet exemple)
COPY_DIR="." 

# --- SCRIPT D'AUTOMATISATION ---

echo "Démarrage de la création des programmes COBOL CHECKER..."

# 1. Parcourir tous les fichiers dans le répertoire des COPY.
# On utilise find pour une meilleure robustesse, mais ls fonctionne aussi.
# Ajustez le critère si vos fichiers ont une extension spécifique (ex: *.cpy)
find "$COPY_DIR" -maxdepth 1 -type f -name "*$COPY_EXTENSION" | while read copy_path; do
    
    # Extraire le nom du fichier (sans le chemin)
    copy_filename=$(basename "$copy_path")
    
    # Supprimer l'extension éventuelle pour obtenir le nom du membre pur pour l'instruction COPY
    if [ -n "$COPY_EXTENSION" ]; then
        copy_member_name="${copy_filename%$COPY_EXTENSION}"
    else
        copy_member_name="$copy_filename"
    fi
    
    # Définir le nom du nouveau programme COBOL (.cbl)
    # Le nom du programme COBOL est le nom du fichier COPY (sans extension) suivi de _CHK (pour Checker)
    cobol_program_name="${copy_member_name}_CHK"
    cobol_file="${cobol_program_name}.cbl"
    
    # Vérification pour éviter d'écraser des fichiers existants (optionnel)
    if [ -f "$cobol_file" ]; then
        echo "  [INFO] Le fichier $cobol_file existe déjà. Suppression..."
        rm "$cobol_file"
    fi

    # 2. Créer le contenu du fichier COBOL
    cat > "$cobol_file" << EOL
       IDENTIFICATION DIVISION.
       PROGRAM-ID. ${cobol_program_name}.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
           COPY $copy_member_name.
       PROCEDURE DIVISION.
           STOP RUN.
EOL

    echo "  [OK] Création de $cobol_file pour la COPY $copy_member_name"
done

echo "Processus terminé."




#!/usr/bin/env bash
# Script de compilation (utilisant cob2)

echo "Compilation des programmes CHECKER..."

# Boucler sur tous les nouveaux fichiers .cbl
find . -maxdepth 1 -type f -name "*_CHK.cbl" | while read cobol_file; do
    echo "  -> Compilation de $cobol_file..."
    
    # Commande cob2 pour générer le listing sans module objet
    # Assurez-vous d'ajouter ici le chemin de recherche si nécessaire (-qSYSLIB)
    cob2 -qLIST -qNOOBJECT "$cobol_file" > "${cobol_file%.cbl}.lst" 2>&1
    
    if [ $? -eq 0 ]; then
        echo "     [SUCCÈS]"
    else
        echo "     [ERREUR] - Vérifiez le fichier de listing ${cobol_file%.cbl}.lst"
    fi
done

echo "Compilation de masse terminée. Les listings sont prêts pour l'analyse."




