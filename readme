
Voici la traduction en anglais de ton message :

---

üîÑ Resuming the Technical Workshop  
We propose to resume the workshop that began on November 5, picking up exactly where we left off. This time, we have the necessary permissions on the USS directories, which will allow us to move forward without any blockers.

üë• Technical Support  
To support this session, our system engineer Lauren will be joining us to provide her expertise and assist with any technical issues that may arise.

---

Souhaites-tu que je l‚Äôadapte pour un email formel, une invitation ou une note interne ?




C'est avec plaisir que je vous fournis un exemple complet de script Bash ex√©cut√© sous z/OS UNIX System Services (USS) pour lancer un programme COBOL r√©sidant dans une biblioth√®que de chargement MVS traditionnelle.

Comme discut√© pr√©c√©demment, l'outil cl√© pour r√©aliser cette op√©ration est la commande `tso`, qui permet d'ex√©cuter des commandes TSO/E depuis l'environnement shell USS.

### Exemple de Script Bash (USS)

Ce script utilise la commande `tso call` pour ex√©cuter un module de chargement MVS.

```bash
#!/bin/bash

# =============================================================
# VARIABLES DE CONFIGURATION (√† adapter)
# =============================================================

# Le pr√©fixe des biblioth√®ques Language Environment (LE)
# Remplacer 'CEE' par le pr√©fixe LE correct de votre installation si n√©cessaire.
LE_PREFIX="CEE" 

# Le nom de la biblioth√®que de chargement MVS historique (DSNAME) 
# qui contient votre programme COBOL.
MVS_LOADLIB="VOTRE.LIBRAIRIE.LOAD.MVS"

# Le nom du module de chargement COBOL √† ex√©cuter (membre).
COBOL_PROGRAM="MONCOBOL"

# Arguments optionnels √† passer au programme (laisser vide si non n√©cessaire)
# Dans l'environnement MVS, les arguments sont souvent pass√©s comme une cha√Æne.
PROGRAM_ARGS="'ARGUMENT1 ARGUMENT2'"

# =============================================================
# 1. Configuration de l'environnement d'ex√©cution (STEPLIB)
# =============================================================

# Pour s'assurer que l'environnement Language Environment (LE) 
# et les biblioth√®ques d'application (MVS_LOADLIB) sont trouv√©es.
# Nous ajoutons les biblioth√®ques LE SCEERUN et SCEERUN2, n√©cessaires 
# pour l'ex√©cution des programmes COBOL sous z/OS.

export STEPLIB=${MVS_LOADLIB}:${LE_PREFIX}.SCEERUN:${LE_PREFIX}.SCEERUN2

echo "STEPLIB configur√©e pour la recherche MVS."

# =============================================================
# 2. Ex√©cution du programme MVS via la commande tso
# =============================================================

# La syntaxe utilise la commande TSO "CALL" : call 'dsn(member)' 'parameters'
# L'utilitaire 'tso' ex√©cutable depuis le shell UNIX est utilis√© pour 
# d√©marrer l'ex√©cution d'un programme MVS.

echo "Lancement du programme COBOL ${COBOL_PROGRAM}..."

tso "CALL '${MVS_LOADLIB}(${COBOL_PROGRAM})' ${PROGRAM_ARGS}"

# V√©rification du code retour du dernier programme (le programme COBOL)
RC=$?

echo "Ex√©cution termin√©e. Code retour du TSO CALL : $RC"

# Fin du script
exit $RC
```

### D√©tails du Script

1.  **`export STEPLIB`**: Lorsque vous ex√©cutez un programme MVS (ici `MONCOBOL`) depuis le shell USS via `tso`, vous devez garantir que l'environnement MVS sous-jacent peut localiser :
    *   Les biblioth√®ques d'ex√©cution de Language Environment (LE), comme `SCEERUN` et `SCEERUN2`.
    *   Le module de chargement de l'application lui-m√™me (`MVS_LOADLIB`) s'il ne se trouve pas dans les biblioth√®ques syst√®me par d√©faut (LNKLST).
    *   La variable d'environnement `STEPLIB` dans l'environnement shell UNIX est utilis√©e pour d√©finir le `STEPLIB` (chemin de recherche des modules de chargement) pour le processus TSO lanc√©.

2.  **`tso "CALL '...'" `**: C'est la commande qui effectue la transition conceptuelle de l'environnement USS (shell) vers l'environnement MVS (ex√©cution de programme). Le format requis pour ex√©cuter un programme MVS catalogu√© depuis le shell est `tso "call 'my.loadlib(myprog)'"`.

3.  **`PROGRAM_ARGS`**: Si votre programme COBOL utilise la clause `USING` dans sa `PROCEDURE DIVISION` pour recevoir des param√®tres, ces arguments doivent √™tre pass√©s sous la forme d'une cha√Æne entre guillemets simples (qui sont ensuite englob√©s par les guillemets doubles de la commande `tso`) dans la syntaxe `CALL`.


--------------
Choisir l'encodage correct pour les fichiers dans l'environnement z/OS UNIX System Services (USS) est crucial en raison de la nature EBCDIC de la plateforme.

Le choix d√©pend de l'utilisation pr√©vue du fichier (donn√©es, script, source de programme) et des besoins de portabilit√© ou d'interop√©rabilit√© avec le reste de MVS.

Voici les recommandations d'encodage bas√©es sur les sources pour les diff√©rents types de fichiers que vous avez mentionn√©s :

### 1. Recommandations G√©n√©rales (Plateforme EBCDIC)

L'environnement z/OS est intrins√®quement une **plateforme EBCDIC**. Le *shell* z/OS et les utilitaires sont configur√©s comme des programmes EBCDIC, attendant que les caract√®res soient cod√©s dans le jeu de caract√®res EBCDIC.

Le *codeset* EBCDIC par d√©faut le plus souvent utilis√© dans l'environnement USS/Shell est **IBM-1047** (Latin 1/Open Systems Interconnection code page 01047).

Le *codeset* ASCII le plus courant pour la conversion ou la portabilit√© est **ISO8859-1**.

L'environnement prend √©galement en charge le **Jeu de caract√®res double-octet (DBCS)**, notamment le *codeset* **IBM-939** pour le DBCS.

---

### 2. Encodage des Fichiers de Donn√©es

Le choix de l'encodage d√©pend de l'origine et de la destination des donn√©es.

| Type de Donn√©es/Fichier | Encodage Recommand√© | Justification / D√©tails |
| :--- | :--- | :--- |
| **Fichiers de donn√©es texte internes USS** | **IBM-1047** | C'est l'encodage EBCDIC par d√©faut du *shell* et des utilitaires USS. L'interop√©rabilit√© avec d'autres composants non-UNIX de MVS peut √™tre am√©lior√©e si le *locale* du *shell* est compatible avec le *codeset* MVS. |
| **Fichiers de donn√©es texte pour portabilit√©/√©change** | **ASCII (ISO8859-1)** ou **UTF-8** | Ces fichiers sont souvent n√©cessaires lors du portage d'applications ou de la r√©ception de donn√©es de syst√®mes externes. Utilisez le *tagging* (`chtag -tc ISO8859-1` ou `chtag -tc UTF-8`) pour indiquer l'encodage r√©el. |
| **Fichiers de donn√©es binaires** | Aucun encodage texte / **Binaire** | Les fichiers binaires doivent √™tre marqu√©s comme `binary` (`chtag -b`). Lorsque vous copiez des donn√©es binaires entre MVS et UNIX, utilisez l'option `BINARY` avec les commandes OCOPY/OGET/OPUT/OGETX/OPUTX, car elles ne tiennent pas compte des caract√®res de fin de ligne ou des caract√©ristiques DBCS. |
| **Fichiers de donn√©es DBCS/Multioctet** | **IBM-939** | C'est le *codeset* DBCS pris en charge par le *shell*. Si les donn√©es DBCS sont dans un autre *codeset* (comme IBM-932), elles doivent √™tre converties en IBM-939 √† l'aide de l'utilitaire `iconv`. |

---

### 3. Encodage des Scripts (Shell et Python)

#### A. Scripts Shell (`sh`, `tcsh`)

Le *codeset* dans lequel un *script shell* est encod√© **doit correspondre au *codeset* du *locale* dans lequel il est ex√©cut√©**.

*   **Choix recommand√© : IBM-1047**
    *   Le *locale* par d√©faut du *shell* et des utilitaires est **C**, qui utilise le *codeset* **IBM-1047**.
    *   Si le script est destin√© √† √™tre utilis√© par plusieurs utilisateurs ayant des *locales* diff√©rents (non-IBM-1047), il est n√©cessaire d'avoir **plusieurs copies du script** (une par *codeset* de *locale*). Vous pouvez utiliser la commande `iconv` pour convertir un *script shell* d'un *codeset* √† un autre.
    *   Si les *scripts shell* sont *tagu√©s* et que la conversion automatique est d√©sactiv√©e, l'encodage du script doit correspondre au *codeset* du *locale* d'ex√©cution.
    *   Si les *scripts shell* sont *tagu√©s* et que la conversion automatique est activ√©e, le *locale* doit indiquer un *codeset* **SBCS** (Single-Byte Character Set) et le script doit √™tre SBCS.

#### B. Scripts Python

**Tous les textes g√©r√©s par l'interpr√©teur Python sont repr√©sent√©s en UTF-8**. Cependant, les fichiers sources eux-m√™mes peuvent √™tre en EBCDIC ou en ASCII.

*   **Choix recommand√© pour le fichier source:**
    1.  **EBCDIC (IBM-1047)** : Support√© nativement, mais n√©cessite un *tag* correct.
    2.  **ASCII (ISO8859-1)** : Support√©, mais doit √™tre *tagu√©* correctement.
    3.  **UTF-8 (CCSID 13497)** : Bien que l'interpr√©teur utilise l'UTF-8 en interne, les fichiers sources peuvent √™tre encod√©s en UTF-8 et devraient √™tre *tagu√©s* (souvent avec ISO8859-1 si l'on se r√©f√®re aux exemples de tagging fournis dans les sources pour les fichiers UTF-8).

*   **Recommandation cruciale : Taguer les fichiers sources**
    Il est fortement recommand√© de **taguer tous les fichiers sources Python avec leur encodage correct** en utilisant l'utilitaire `chtag`. Par d√©faut, un fichier non *tagu√©* ou un nouveau fichier sera trait√© comme EBCDIC.
    *   Exemple EBCDIC : `chtag -tc IBM-1047 script.py`.
    *   Exemple UTF-8 : `chtag -tc ISO8859-1 script.py` (comme illustr√© dans les exemples o√π ISO8859-1 est utilis√© pour taguer les fichiers sources UTF-8).

---

### 4. Encodage des Sources Compilables (C/C++, Java)

#### A. Sources C/C++ (Compilation avec `c89`, `cc`, `c++`, `gcc`/`xlc`)

Les programmes C/C++ sur z/OS peuvent √™tre compil√©s soit comme des programmes EBCDIC, soit, gr√¢ce aux extensions Enhanced ASCII, comme des programmes ASCII.

*   **Choix recommand√© : EBCDIC (IBM-1047)**
    *   La plateforme est EBCDIC, et les utilitaires du *shell* sont EBCDIC. L'encodage par d√©faut EBCDIC pour un *thread* C/C++ est **IBM-1047**.
    *   Les sources C/C++ peuvent √™tre dans des *data sets* MVS (qui sont typiquement EBCDIC) ou des fichiers USS.
*   **Alternative pour la portabilit√© (Compilation ASCII) : ISO8859-1 (CCSID 819)**
    *   Les programmes C peuvent √™tre **compil√©s comme ASCII**.
    *   Si vous portez une application ou si vous souhaitez que le programme utilise l'ASCII, vous pouvez utiliser le **compilateur ASCII** pour changer le *codeset* du programme √† **819 (ISO8859-1 ASCII)**.
    *   Lors du portage d'applications XPG 4.2 √©crites en ASCII, il est possible de compiler en ASCII et de *taguer* les fichiers texte comme ASCII, permettant √† USS d'effectuer la conversion automatique lorsque n√©cessaire.

#### B. Sources Java

Les sources ne mentionnent pas sp√©cifiquement Java, mais Java fait partie des applications port√©es ou d√©velopp√©es. √âtant donn√© que Java utilise g√©n√©ralement Unicode (et souvent UTF-8) pour les sources et les cha√Ænes internes, il serait logique d'utiliser un encodage Unicode ou ASCII pour la source, avec un *tag* appropri√©, comme pour les applications port√©es.

*   **Recommandation implicite : UTF-8 ou ASCII**
    *   Si la source est stock√©e dans USS, l'utilisation de **UTF-8** ou **ISO8859-1** est typique pour les plateformes multiplateformes (similaire aux scripts Python).
    *   Le fichier source doit √™tre **correctement *tagu√©*** pour que les outils (comme le compilateur Java, non explicitement couvert ici mais fonctionnant sur z/OS) puissent lire l'encodage correct. Les services Unicode sont disponibles pour g√©rer la conversion si n√©cessaire.

----------------------
La r√©f√©rence sur laquelle s'appuyer pour d√©terminer le niveau de compatibilit√© de z/OS UNIX System Services (USS) est l'ensemble des normes **POSIX** et **X/Open**.

Voici les d√©tails concernant la r√©f√©rence et la nature de cet environnement :

### R√©f√©rences de Compatibilit√©

z/OS UNIX System Services est con√ßu pour se conformer aux normes ouvertes √©tablies pour les environnements de type UNIX. Les normes cl√©s sont :

1.  **Portable Operating System Interface (POSIX)** : L'API et l'interface shell de z/OS UNIX System Services sont bas√©es sur les normes ouvertes du projet **IEEE Portable Operating System Interface (POSIX)**.
2.  **X/Open Portability Guide Issue 4 (XPG4)** : z/OS UNIX System Services fournit une interface compatible avec la norme **XPG4 UNIX 1995 conformance**.

De nombreux utilitaires et commandes du shell z/OS sont √©valu√©s pour leur compatibilit√© avec les normes **POSIX.2** et **X/Open Portability Guide** (XPG). Par exemple, la commande `getconf` peut fournir la valeur `POSIX2_VERSION`, qui sp√©cifie la version de POSIX.2 respect√©e dans cette version.

### Nature de z/OS UNIX System Services

z/OS UNIX System Services (USS) est un composant du syst√®me d'exploitation **z/OS**. Il fournit une interface √† normes ouvertes au syst√®me d'exploitation z/OS.

*   **Est-ce un UNIX ?** L'environnement fourni par z/OS UNIX System Services est un environnement qui respecte les normes **UNIX**. Le terme "UNIX" est une marque d√©pos√©e de **The Open Group**. Les shells et utilitaires fournis (InterOpen Shell and Utilities) fournissent les fonctions **POSIX.2 (Shell and Utilities)** √† z/OS UNIX System Services.
*   **Compatibilit√© avec les syst√®mes traditionnels :** L'environnement comprend des utilitaires qui sont pris en charge pour la **compatibilit√© avec les syst√®mes UNIX plus anciens** (y compris les syst√®mes **UNIX System V** et **Berkeley Software Distribution (BSD)**, bien que non explicitement nomm√©s comme des distributions compl√®tes). Par exemple, le compilateur `cc` est pris en charge pour la compatibilit√© avec les syst√®mes UNIX plus anciens, mais la commande `c89` est recommand√©e car elle est consid√©r√©e comme la norme pour les applications UNIX portables d√©finie par POSIX.2.
*   **Est-ce un Linux ?** Les sources d√©crivent USS comme un environnement qui se conforme aux normes POSIX et XPG4 dans le cadre de z/OS. Il n'est pas qualifi√© de "Linux".

En r√©sum√©, z/OS UNIX System Services fournit un environnement de type **UNIX** hautement conforme aux normes **POSIX** et **XPG4**, fonctionnant comme une couche int√©gr√©e au syst√®me d'exploitation **z/OS**.
----------------------
Pour tester l'existence d'un *data set* MVS (MVS data set) dans un *script shell* z/OS, vous devez ex√©cuter une commande ou un utilitaire qui tente d'acc√©der au *data set* MVS et v√©rifier ensuite le statut de sortie (exit status) de cette commande.ss

√âtant donn√© que les *data sets* MVS ne sont pas des fichiers de syst√®me de fichiers z/OS UNIX standards, les op√©rateurs de test de fichiers traditionnels du shell (comme `test -f pathname` ou `[[ -e pathname ]]`) ne sont pas applicables directement pour v√©rifier l'existence de *data sets* MVS.

Voici la d√©marche et les m√©thodes bas√©es sur les sources :

### 1. Utilisation d'une commande TSO/E (`tso` ou `tsocmd`)

La m√©thode la plus courante consiste √† ex√©cuter une commande TSO/E depuis le *script shell*, car les commandes TSO/E sont con√ßues pour interagir avec les *data sets* MVS.

Vous pouvez utiliser la commande `tso` ou `tsocmd` pour ex√©cuter une commande TSO/E qui tente de v√©rifier si le *data set* est catalogu√©. Le statut de sortie de la commande TSO/E sera renvoy√© comme statut de sortie du shell (`$?`).

#### Syntaxe pour ex√©cuter une commande TSO/E et v√©rifier le statut :

```sh
# D√©finir le nom du data set MVS. 
# Les noms de data sets MVS doivent √™tre pr√©c√©d√©s de double barres (//)
# et les noms pleinement qualifi√©s doivent √™tre mis entre guillemets simples ('), 
# eux-m√™mes √©chapp√©s ou plac√©s entre guillemets doubles du shell.
DSN_MVS="//'VOTRE.DATASET.MVS.NAME'"

# Exemple : Ex√©cuter la commande TSO/E LISTCAT (non explicitement document√©e 
# dans les extraits, mais utilis√©e pour v√©rifier l'existence dans l'environnement MVS)
# et rediriger la sortie vers /dev/null
tso "LISTCAT ENTRY('$DSN_MVS') " > /dev/null 2>&1

# Capturer le statut de sortie de la commande tso
RC=$?

if [ $RC -eq 0 ]; then
    echo "Le data set MVS existe."
else
    echo "Le data set MVS n'existe pas ou l'acc√®s a √©chou√©."
fi
```

**Points importants concernant les noms de *data sets* MVS dans le shell :**
1.  Pour distinguer un *data set* MVS d'un fichier z/OS UNIX, **il faut le pr√©c√©der de deux barres obliques (//)**.
2.  Un nom de *data set* pleinement qualifi√© doit √™tre entour√© de **guillemets simples** (comme on le ferait sous TSO). Pour √©viter que ces guillemets simples ne soient interpr√©t√©s par le shell, il faut placer l'ensemble entre **guillemets doubles** ou √©chapper les guillemets simples/parenth√®ses.

### 2. Utilisation d'un utilitaire shell supportant les *data sets* MVS

Plusieurs utilitaires shell sont capables de lire directement les *data sets* MVS, tels que `md5`, `sha1`, `sha256`, `sha384`, `sha512`, ou `mv`. Si vous tentez d'ex√©cuter un tel utilitaire sur un *data set* inexistant, il devrait √©chouer et retourner un statut de sortie non nul.

Par exemple, en utilisant la commande `sha256`, qui prend en charge la lecture de *data sets* s√©quentiels MVS ou de membres PDS/PDSE :

```sh
# Nom du data set MVS pleinement qualifi√©, correctement √©chapp√©
DSN_MVS="//'USERID.MY.DATASET'"

# Tenter d'ex√©cuter sha256 sur le data set. Rediriger la sortie standard et d'erreur.
sha256 "$DSN_MVS" > /dev/null 2>&1

# V√©rifier le statut de sortie
RC=$?

# Un statut de 0 indique g√©n√©ralement une ex√©cution r√©ussie (donc que le fichier existe et a pu √™tre ouvert).
# Un statut de 1 peut indiquer une incapacit√© √† ouvrir le fichier (Inability to open a file), 
# ce qui se produit s'il n'existe pas ou est inaccessible.
if [ $RC -eq 0 ]; then
    echo "Le data set MVS existe et est accessible."
else
    echo "Le data set MVS n'existe pas ou une erreur d'acc√®s s'est produite (RC=$RC)."
fi
```

### 3. Utilisation de la structure conditionnelle `if`

Quelle que soit la commande utilis√©e pour tester l'existence, vous pouvez int√©grer la v√©rification du statut de sortie (`$?`) dans une structure conditionnelle `if`. Le statut de sortie d'une commande est consid√©r√© comme **vrai** (true) si sa valeur est **0** (succ√®s) et **faux** (false) si elle est **non nulle**.

Vous pouvez utiliser la syntaxe `if command; then ... fi` ou la syntaxe `if [ expression ]; then ... fi`. Si vous utilisez la commande `test` (ou `[ ]`), l'expression renvoie un statut (0 pour vrai, 1 pour faux).

Exemple de structure `if` dans un script shell, utilisant la v√©rification du statut apr√®s l'ex√©cution d'une commande TSO/E :

```sh
# Ex√©cute la commande TSO/E (elle renvoie 0 si elle r√©ussit, non-z√©ro si elle √©choue)
tso "ALLOCATE F(TESTDD) DSN('VOTRE.DATASET.MVS.NAME') SHR" > /dev/null 2>&1

if [ $? -eq 0 ]; then
    # Statut de 0 : Succ√®s de l'allocation (le data set existe)
    echo "Le data set est pr√©sent."
    tso "FREE F(TESTDD)"
elif [ $? -ne 0 ]; then
    # Statut non nul : √âchec de l'allocation (le data set n'existe pas ou autre erreur)
    echo "Le data set est absent ou erreur d'acc√®s."
fi
```

**Note sur `[[...]]` :** La syntaxe double crochet `[[ test_expr ]]` est √©galement support√©e dans le shell z/OS et permet de tester des expressions. Cependant, elle fonctionne sur le statut de sortie de l'expression interne, qui est d√©fini par la commande `test` ou par des op√©rateurs internes au shell, mais elle est surtout pertinente pour les fichiers UNIX ou les comparaisons de cha√Ænes/nombres. Pour interagir avec le syst√®me MVS, il est souvent plus simple d'utiliser `tso`/`tsocmd` et de v√©rifier la valeur de `$?`.



