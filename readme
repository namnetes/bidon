
Absolument ! Voici un brouillon d'e-mail que vous pouvez adapter et envoyer √† votre communaut√©, r√©sumant le succ√®s de l'installation et les b√©n√©fices de la nouvelle version.
Objet : üöÄ Changement de version r√©ussi : ChangeMan ZMF 8.3.1 est d√©sormais en production !
Bonjour √† tous,
Nous sommes heureux de vous annoncer que la mise √† jour de notre environnement de gestion des changements ChangeMan ZMF vers la version 8.3.1 a √©t√© r√©alis√©e avec succ√®s ce week-end. Tous les services sont pleinement op√©rationnels.
‚úÖ Ce qui a √©t√© mis √† jour
| √âl√©ment | Ancienne Version | Nouvelle Version |
|---|---|---|
| Serveur ChangeMan ZMF | 8.3 | 8.3.1 |
üìÖ Rappel sur la 8.3.1
Pour information, la version 8.3.1 (souvent appel√©e 8.3 Patch 1) a √©t√© initialement publi√©e par Rocket Software vers d√©cembre 2024 / d√©but 2025.
üåü Ce que vous apporte cette nouvelle version
La version 8.3.1 est principalement ax√©e sur la stabilit√©, la performance et la consolidation de la plateforme, suite aux √©volutions majeures de la 8.3.
 * Stabilit√© et Performance Accrues : Cette version int√®gre de nombreux correctifs qui r√©solvent des probl√®mes de stabilit√© et des optimisations de performance identifi√©s dans la 8.3, notamment pour la gestion des ressources et les traitements batch critiques.
 * Fiabilit√© des Int√©grations : Am√©lioration de la robustesse des services XML et des API REST. Cela renforce la fiabilit√© de nos outils d'int√©gration externes (CI/CD) qui communiquent avec ChangeMan.
 * Am√©lioration de l'Exp√©rience Utilisateur : Mise √† jour des composants clients et des squelettes ISPF pour une meilleure coh√©rence et des corrections d'ergonomie mineures.
 * Compatibilit√© Client : Elle assure la compatibilit√© avec les derni√®res versions des outils clients comme ChangeMan ZMF for Eclipse (ZMF4ECL) et ChangeMan ZDD.
‚ö†Ô∏è Prochaine √âtape pour les Utilisateurs
Si vous utilisez des clients graphiques tels que ZMF for Eclipse ou si vous avez des scripts personnalis√©s utilisant les Services XML, veuillez v√©rifier que vos outils sont √† jour pour garantir une compatibilit√© totale avec le nouveau serveur.
Pour toute question ou en cas de probl√®me rencontr√©, veuillez contacter imm√©diatement l'√©quipe support √† [Adresse E-mail du Support].
Merci pour votre collaboration pendant cette maintenance.
Cordialement,
L'√©quipe [Nom de votre √©quipe/D√©partement]






CICS est un environnement d'ex√©cution principal pour les programmes (COBOL, Java) sur z/OS, mais z/OS Connect peut acc√©der √† d'autres environnements :1. Acc√®s Via des Services d'Ex√©cution :EnvironnementR√¥leAcc√®s √† z/OS ConnectCICSEnvironnement Transactionnel (COBOL, Java)Oui, tr√®s courant (pour VSAM, bases de donn√©es, files d'attente).IMSEnvironnement Transactionnel et Base de Donn√©es (COBOL, Java)Oui, utilis√© pour acc√©der aux bases de donn√©es et transactions IMS.Liberty Profile (Int√©gr√© √† z/OS Connect)Environnement JavaOui, les services d√©velopp√©s directement en Java (servlets, JAX-RS) y s'ex√©cutent.Db2Base de Donn√©es RelationnelleOui, z/OS Connect peut appeler des Proc√©dures Stock√©es Db2 ou, via le File Manager Service Provider, y acc√©der directement via SQL.2. Acc√®s Direct via File Manager Service ProviderComme mentionn√© pr√©c√©demment, le File Manager Service Provider est une exception :Il permet de cr√©er des API pour acc√©der √† des ressources (comme VSAM ou des fichiers s√©quentiels) sans passer par un programme CICS ou IMS.Le Service Provider utilise directement les capacit√©s de gestion des donn√©es de File Manager, ce qui est id√©al pour de la simple consultation de donn√©es.En conclusion, que votre service soit d√©velopp√© en COBOL (sous CICS), en Java (sous Liberty), ou qu'il soit g√©n√©r√© par le File Manager Service Provider, le r√©sultat final est une API RESTful standard que tout client Open peut appeler sur le r√©seau, bien au-del√† des limites de CICS.



Ressources Accessibles via API
Le fournisseur de services utilise les capacit√©s avanc√©es d'IBM File Manager for z/OS pour interpr√©ter les structures de donn√©es (via les Copybooks) et interroger directement les types de ressources suivants :

Fichiers VSAM (Virtual Storage Access Method) : La m√©thode courante pour exposer les donn√©es VSAM sous forme d'API.

Fichiers S√©quentiels MVS et PDS/PDSE : Acc√®s aux fichiers traditionnels du syst√®me d'exploitation z/OS.

Bases de donn√©es Relationnelles (Db2) : Vous pouvez exposer les donn√©es des tables Db2 via des requ√™tes SQL int√©gr√©es aux API.

Bases de donn√©es Hi√©rarchiques (IMS) : Acc√®s aux donn√©es stock√©es dans les bases de donn√©es IMS.

Ressources CICS : Acc√®s aux files d'attente de stockage temporaire (TS) et de donn√©es transitoires (TD) de CICS.

Ressources MQ : Acc√®s aux messages dans les files d'attente WebSphere MQ.

En utilisant les mod√®les (templates) de File Manager, vous d√©finissez le sch√©ma de l'API (le format JSON/XML) et le mappage vers les donn√©es mainframe, et le Service Provider g√®re tout le reste : la connexion, la lecture, et la conversion des donn√©es EBCDIC vers ASCII/JSON.
--------------------------------------
File Manager Service Provider for z/OS¬Æ Connect Enterprise Edition
File Manager Service Provider for IBM¬Æ z/OS¬Æ Connect Enterprise Edition enables client applications to access IBM¬Æ Z data sources using z/OS¬Æ Connect.

Using z/OS¬Æ Connect tooling, customers can create their own RESTful APIs and access IBM¬Æ Z data sources through the service provider. Clients can read data sequentially, by relative record position, or by key.

The supported data sources include:
MVS‚Ñ¢ data sets (including VSAM)
UNIX System Services files
CICS¬Æ files (including VSAM and CICS¬Æ TS and CICS¬Æ TD queues)
Websphere MQ queues
Db2¬Æ
IMS‚Ñ¢
Installation and customization of the service provider is described in the File Manager Customization Guide.
-------------------------------------------------------------------------

C'est avec plaisir que je vous fournis un exemple complet de script Bash ex√©cut√© sous z/OS UNIX System Services (USS) pour lancer un programme COBOL r√©sidant dans une biblioth√®que de chargement MVS traditionnelle.

Comme discut√© pr√©c√©demment, l'outil cl√© pour r√©aliser cette op√©ration est la commande `tso`, qui permet d'ex√©cuter des commandes TSO/E depuis l'environnement shell USS.

### Exemple de Script Bash (USS)

Ce script utilise la commande `tso call` pour ex√©cuter un module de chargement MVS.

```bash
#!/bin/bash

# =============================================================
# VARIABLES DE CONFIGURATION (√† adapter)
# =============================================================

# Le pr√©fixe des biblioth√®ques Language Environment (LE)
# Remplacer 'CEE' par le pr√©fixe LE correct de votre installation si n√©cessaire.
LE_PREFIX="CEE" 

# Le nom de la biblioth√®que de chargement MVS historique (DSNAME) 
# qui contient votre programme COBOL.
MVS_LOADLIB="VOTRE.LIBRAIRIE.LOAD.MVS"

# Le nom du module de chargement COBOL √† ex√©cuter (membre).
COBOL_PROGRAM="MONCOBOL"

# Arguments optionnels √† passer au programme (laisser vide si non n√©cessaire)
# Dans l'environnement MVS, les arguments sont souvent pass√©s comme une cha√Æne.
PROGRAM_ARGS="'ARGUMENT1 ARGUMENT2'"

# =============================================================
# 1. Configuration de l'environnement d'ex√©cution (STEPLIB)
# =============================================================

# Pour s'assurer que l'environnement Language Environment (LE) 
# et les biblioth√®ques d'application (MVS_LOADLIB) sont trouv√©es.
# Nous ajoutons les biblioth√®ques LE SCEERUN et SCEERUN2, n√©cessaires 
# pour l'ex√©cution des programmes COBOL sous z/OS.

export STEPLIB=${MVS_LOADLIB}:${LE_PREFIX}.SCEERUN:${LE_PREFIX}.SCEERUN2

echo "STEPLIB configur√©e pour la recherche MVS."

# =============================================================
# 2. Ex√©cution du programme MVS via la commande tso
# =============================================================

# La syntaxe utilise la commande TSO "CALL" : call 'dsn(member)' 'parameters'
# L'utilitaire 'tso' ex√©cutable depuis le shell UNIX est utilis√© pour 
# d√©marrer l'ex√©cution d'un programme MVS.

echo "Lancement du programme COBOL ${COBOL_PROGRAM}..."

tso "CALL '${MVS_LOADLIB}(${COBOL_PROGRAM})' ${PROGRAM_ARGS}"

# V√©rification du code retour du dernier programme (le programme COBOL)
RC=$?

echo "Ex√©cution termin√©e. Code retour du TSO CALL : $RC"

# Fin du script
exit $RC
```

### D√©tails du Script

1.  **`export STEPLIB`**: Lorsque vous ex√©cutez un programme MVS (ici `MONCOBOL`) depuis le shell USS via `tso`, vous devez garantir que l'environnement MVS sous-jacent peut localiser :
    *   Les biblioth√®ques d'ex√©cution de Language Environment (LE), comme `SCEERUN` et `SCEERUN2`.
    *   Le module de chargement de l'application lui-m√™me (`MVS_LOADLIB`) s'il ne se trouve pas dans les biblioth√®ques syst√®me par d√©faut (LNKLST).
    *   La variable d'environnement `STEPLIB` dans l'environnement shell UNIX est utilis√©e pour d√©finir le `STEPLIB` (chemin de recherche des modules de chargement) pour le processus TSO lanc√©.

2.  **`tso "CALL '...'" `**: C'est la commande qui effectue la transition conceptuelle de l'environnement USS (shell) vers l'environnement MVS (ex√©cution de programme). Le format requis pour ex√©cuter un programme MVS catalogu√© depuis le shell est `tso "call 'my.loadlib(myprog)'"`.

3.  **`PROGRAM_ARGS`**: Si votre programme COBOL utilise la clause `USING` dans sa `PROCEDURE DIVISION` pour recevoir des param√®tres, ces arguments doivent √™tre pass√©s sous la forme d'une cha√Æne entre guillemets simples (qui sont ensuite englob√©s par les guillemets doubles de la commande `tso`) dans la syntaxe `CALL`.


--------------
Choisir l'encodage correct pour les fichiers dans l'environnement z/OS UNIX System Services (USS) est crucial en raison de la nature EBCDIC de la plateforme.

Le choix d√©pend de l'utilisation pr√©vue du fichier (donn√©es, script, source de programme) et des besoins de portabilit√© ou d'interop√©rabilit√© avec le reste de MVS.

Voici les recommandations d'encodage bas√©es sur les sources pour les diff√©rents types de fichiers que vous avez mentionn√©s :

### 1. Recommandations G√©n√©rales (Plateforme EBCDIC)

L'environnement z/OS est intrins√®quement une **plateforme EBCDIC**. Le *shell* z/OS et les utilitaires sont configur√©s comme des programmes EBCDIC, attendant que les caract√®res soient cod√©s dans le jeu de caract√®res EBCDIC.

Le *codeset* EBCDIC par d√©faut le plus souvent utilis√© dans l'environnement USS/Shell est **IBM-1047** (Latin 1/Open Systems Interconnection code page 01047).

Le *codeset* ASCII le plus courant pour la conversion ou la portabilit√© est **ISO8859-1**.

L'environnement prend √©galement en charge le **Jeu de caract√®res double-octet (DBCS)**, notamment le *codeset* **IBM-939** pour le DBCS.

---

### 2. Encodage des Fichiers de Donn√©es

Le choix de l'encodage d√©pend de l'origine et de la destination des donn√©es.

| Type de Donn√©es/Fichier | Encodage Recommand√© | Justification / D√©tails |
| :--- | :--- | :--- |
| **Fichiers de donn√©es texte internes USS** | **IBM-1047** | C'est l'encodage EBCDIC par d√©faut du *shell* et des utilitaires USS. L'interop√©rabilit√© avec d'autres composants non-UNIX de MVS peut √™tre am√©lior√©e si le *locale* du *shell* est compatible avec le *codeset* MVS. |
| **Fichiers de donn√©es texte pour portabilit√©/√©change** | **ASCII (ISO8859-1)** ou **UTF-8** | Ces fichiers sont souvent n√©cessaires lors du portage d'applications ou de la r√©ception de donn√©es de syst√®mes externes. Utilisez le *tagging* (`chtag -tc ISO8859-1` ou `chtag -tc UTF-8`) pour indiquer l'encodage r√©el. |
| **Fichiers de donn√©es binaires** | Aucun encodage texte / **Binaire** | Les fichiers binaires doivent √™tre marqu√©s comme `binary` (`chtag -b`). Lorsque vous copiez des donn√©es binaires entre MVS et UNIX, utilisez l'option `BINARY` avec les commandes OCOPY/OGET/OPUT/OGETX/OPUTX, car elles ne tiennent pas compte des caract√®res de fin de ligne ou des caract√©ristiques DBCS. |
| **Fichiers de donn√©es DBCS/Multioctet** | **IBM-939** | C'est le *codeset* DBCS pris en charge par le *shell*. Si les donn√©es DBCS sont dans un autre *codeset* (comme IBM-932), elles doivent √™tre converties en IBM-939 √† l'aide de l'utilitaire `iconv`. |

---

### 3. Encodage des Scripts (Shell et Python)

#### A. Scripts Shell (`sh`, `tcsh`)

Le *codeset* dans lequel un *script shell* est encod√© **doit correspondre au *codeset* du *locale* dans lequel il est ex√©cut√©**.

*   **Choix recommand√© : IBM-1047**
    *   Le *locale* par d√©faut du *shell* et des utilitaires est **C**, qui utilise le *codeset* **IBM-1047**.
    *   Si le script est destin√© √† √™tre utilis√© par plusieurs utilisateurs ayant des *locales* diff√©rents (non-IBM-1047), il est n√©cessaire d'avoir **plusieurs copies du script** (une par *codeset* de *locale*). Vous pouvez utiliser la commande `iconv` pour convertir un *script shell* d'un *codeset* √† un autre.
    *   Si les *scripts shell* sont *tagu√©s* et que la conversion automatique est d√©sactiv√©e, l'encodage du script doit correspondre au *codeset* du *locale* d'ex√©cution.
    *   Si les *scripts shell* sont *tagu√©s* et que la conversion automatique est activ√©e, le *locale* doit indiquer un *codeset* **SBCS** (Single-Byte Character Set) et le script doit √™tre SBCS.

#### B. Scripts Python

**Tous les textes g√©r√©s par l'interpr√©teur Python sont repr√©sent√©s en UTF-8**. Cependant, les fichiers sources eux-m√™mes peuvent √™tre en EBCDIC ou en ASCII.

*   **Choix recommand√© pour le fichier source:**
    1.  **EBCDIC (IBM-1047)** : Support√© nativement, mais n√©cessite un *tag* correct.
    2.  **ASCII (ISO8859-1)** : Support√©, mais doit √™tre *tagu√©* correctement.
    3.  **UTF-8 (CCSID 13497)** : Bien que l'interpr√©teur utilise l'UTF-8 en interne, les fichiers sources peuvent √™tre encod√©s en UTF-8 et devraient √™tre *tagu√©s* (souvent avec ISO8859-1 si l'on se r√©f√®re aux exemples de tagging fournis dans les sources pour les fichiers UTF-8).

*   **Recommandation cruciale : Taguer les fichiers sources**
    Il est fortement recommand√© de **taguer tous les fichiers sources Python avec leur encodage correct** en utilisant l'utilitaire `chtag`. Par d√©faut, un fichier non *tagu√©* ou un nouveau fichier sera trait√© comme EBCDIC.
    *   Exemple EBCDIC : `chtag -tc IBM-1047 script.py`.
    *   Exemple UTF-8 : `chtag -tc ISO8859-1 script.py` (comme illustr√© dans les exemples o√π ISO8859-1 est utilis√© pour taguer les fichiers sources UTF-8).

---

### 4. Encodage des Sources Compilables (C/C++, Java)

#### A. Sources C/C++ (Compilation avec `c89`, `cc`, `c++`, `gcc`/`xlc`)

Les programmes C/C++ sur z/OS peuvent √™tre compil√©s soit comme des programmes EBCDIC, soit, gr√¢ce aux extensions Enhanced ASCII, comme des programmes ASCII.

*   **Choix recommand√© : EBCDIC (IBM-1047)**
    *   La plateforme est EBCDIC, et les utilitaires du *shell* sont EBCDIC. L'encodage par d√©faut EBCDIC pour un *thread* C/C++ est **IBM-1047**.
    *   Les sources C/C++ peuvent √™tre dans des *data sets* MVS (qui sont typiquement EBCDIC) ou des fichiers USS.
*   **Alternative pour la portabilit√© (Compilation ASCII) : ISO8859-1 (CCSID 819)**
    *   Les programmes C peuvent √™tre **compil√©s comme ASCII**.
    *   Si vous portez une application ou si vous souhaitez que le programme utilise l'ASCII, vous pouvez utiliser le **compilateur ASCII** pour changer le *codeset* du programme √† **819 (ISO8859-1 ASCII)**.
    *   Lors du portage d'applications XPG 4.2 √©crites en ASCII, il est possible de compiler en ASCII et de *taguer* les fichiers texte comme ASCII, permettant √† USS d'effectuer la conversion automatique lorsque n√©cessaire.

#### B. Sources Java

Les sources ne mentionnent pas sp√©cifiquement Java, mais Java fait partie des applications port√©es ou d√©velopp√©es. √âtant donn√© que Java utilise g√©n√©ralement Unicode (et souvent UTF-8) pour les sources et les cha√Ænes internes, il serait logique d'utiliser un encodage Unicode ou ASCII pour la source, avec un *tag* appropri√©, comme pour les applications port√©es.

*   **Recommandation implicite : UTF-8 ou ASCII**
    *   Si la source est stock√©e dans USS, l'utilisation de **UTF-8** ou **ISO8859-1** est typique pour les plateformes multiplateformes (similaire aux scripts Python).
    *   Le fichier source doit √™tre **correctement *tagu√©*** pour que les outils (comme le compilateur Java, non explicitement couvert ici mais fonctionnant sur z/OS) puissent lire l'encodage correct. Les services Unicode sont disponibles pour g√©rer la conversion si n√©cessaire.

----------------------
La r√©f√©rence sur laquelle s'appuyer pour d√©terminer le niveau de compatibilit√© de z/OS UNIX System Services (USS) est l'ensemble des normes **POSIX** et **X/Open**.

Voici les d√©tails concernant la r√©f√©rence et la nature de cet environnement :

### R√©f√©rences de Compatibilit√©

z/OS UNIX System Services est con√ßu pour se conformer aux normes ouvertes √©tablies pour les environnements de type UNIX. Les normes cl√©s sont :

1.  **Portable Operating System Interface (POSIX)** : L'API et l'interface shell de z/OS UNIX System Services sont bas√©es sur les normes ouvertes du projet **IEEE Portable Operating System Interface (POSIX)**.
2.  **X/Open Portability Guide Issue 4 (XPG4)** : z/OS UNIX System Services fournit une interface compatible avec la norme **XPG4 UNIX 1995 conformance**.

De nombreux utilitaires et commandes du shell z/OS sont √©valu√©s pour leur compatibilit√© avec les normes **POSIX.2** et **X/Open Portability Guide** (XPG). Par exemple, la commande `getconf` peut fournir la valeur `POSIX2_VERSION`, qui sp√©cifie la version de POSIX.2 respect√©e dans cette version.

### Nature de z/OS UNIX System Services

z/OS UNIX System Services (USS) est un composant du syst√®me d'exploitation **z/OS**. Il fournit une interface √† normes ouvertes au syst√®me d'exploitation z/OS.

*   **Est-ce un UNIX ?** L'environnement fourni par z/OS UNIX System Services est un environnement qui respecte les normes **UNIX**. Le terme "UNIX" est une marque d√©pos√©e de **The Open Group**. Les shells et utilitaires fournis (InterOpen Shell and Utilities) fournissent les fonctions **POSIX.2 (Shell and Utilities)** √† z/OS UNIX System Services.
*   **Compatibilit√© avec les syst√®mes traditionnels :** L'environnement comprend des utilitaires qui sont pris en charge pour la **compatibilit√© avec les syst√®mes UNIX plus anciens** (y compris les syst√®mes **UNIX System V** et **Berkeley Software Distribution (BSD)**, bien que non explicitement nomm√©s comme des distributions compl√®tes). Par exemple, le compilateur `cc` est pris en charge pour la compatibilit√© avec les syst√®mes UNIX plus anciens, mais la commande `c89` est recommand√©e car elle est consid√©r√©e comme la norme pour les applications UNIX portables d√©finie par POSIX.2.
*   **Est-ce un Linux ?** Les sources d√©crivent USS comme un environnement qui se conforme aux normes POSIX et XPG4 dans le cadre de z/OS. Il n'est pas qualifi√© de "Linux".

En r√©sum√©, z/OS UNIX System Services fournit un environnement de type **UNIX** hautement conforme aux normes **POSIX** et **XPG4**, fonctionnant comme une couche int√©gr√©e au syst√®me d'exploitation **z/OS**.
----------------------
Pour tester l'existence d'un *data set* MVS (MVS data set) dans un *script shell* z/OS, vous devez ex√©cuter une commande ou un utilitaire qui tente d'acc√©der au *data set* MVS et v√©rifier ensuite le statut de sortie (exit status) de cette commande.ss

√âtant donn√© que les *data sets* MVS ne sont pas des fichiers de syst√®me de fichiers z/OS UNIX standards, les op√©rateurs de test de fichiers traditionnels du shell (comme `test -f pathname` ou `[[ -e pathname ]]`) ne sont pas applicables directement pour v√©rifier l'existence de *data sets* MVS.

Voici la d√©marche et les m√©thodes bas√©es sur les sources :

### 1. Utilisation d'une commande TSO/E (`tso` ou `tsocmd`)

La m√©thode la plus courante consiste √† ex√©cuter une commande TSO/E depuis le *script shell*, car les commandes TSO/E sont con√ßues pour interagir avec les *data sets* MVS.

Vous pouvez utiliser la commande `tso` ou `tsocmd` pour ex√©cuter une commande TSO/E qui tente de v√©rifier si le *data set* est catalogu√©. Le statut de sortie de la commande TSO/E sera renvoy√© comme statut de sortie du shell (`$?`).

#### Syntaxe pour ex√©cuter une commande TSO/E et v√©rifier le statut :

```sh
# D√©finir le nom du data set MVS. 
# Les noms de data sets MVS doivent √™tre pr√©c√©d√©s de double barres (//)
# et les noms pleinement qualifi√©s doivent √™tre mis entre guillemets simples ('), 
# eux-m√™mes √©chapp√©s ou plac√©s entre guillemets doubles du shell.
DSN_MVS="//'VOTRE.DATASET.MVS.NAME'"

# Exemple : Ex√©cuter la commande TSO/E LISTCAT (non explicitement document√©e 
# dans les extraits, mais utilis√©e pour v√©rifier l'existence dans l'environnement MVS)
# et rediriger la sortie vers /dev/null
tso "LISTCAT ENTRY('$DSN_MVS') " > /dev/null 2>&1

# Capturer le statut de sortie de la commande tso
RC=$?

if [ $RC -eq 0 ]; then
    echo "Le data set MVS existe."
else
    echo "Le data set MVS n'existe pas ou l'acc√®s a √©chou√©."
fi
```

**Points importants concernant les noms de *data sets* MVS dans le shell :**
1.  Pour distinguer un *data set* MVS d'un fichier z/OS UNIX, **il faut le pr√©c√©der de deux barres obliques (//)**.
2.  Un nom de *data set* pleinement qualifi√© doit √™tre entour√© de **guillemets simples** (comme on le ferait sous TSO). Pour √©viter que ces guillemets simples ne soient interpr√©t√©s par le shell, il faut placer l'ensemble entre **guillemets doubles** ou √©chapper les guillemets simples/parenth√®ses.

### 2. Utilisation d'un utilitaire shell supportant les *data sets* MVS

Plusieurs utilitaires shell sont capables de lire directement les *data sets* MVS, tels que `md5`, `sha1`, `sha256`, `sha384`, `sha512`, ou `mv`. Si vous tentez d'ex√©cuter un tel utilitaire sur un *data set* inexistant, il devrait √©chouer et retourner un statut de sortie non nul.

Par exemple, en utilisant la commande `sha256`, qui prend en charge la lecture de *data sets* s√©quentiels MVS ou de membres PDS/PDSE :

```sh
# Nom du data set MVS pleinement qualifi√©, correctement √©chapp√©
DSN_MVS="//'USERID.MY.DATASET'"

# Tenter d'ex√©cuter sha256 sur le data set. Rediriger la sortie standard et d'erreur.
sha256 "$DSN_MVS" > /dev/null 2>&1

# V√©rifier le statut de sortie
RC=$?

# Un statut de 0 indique g√©n√©ralement une ex√©cution r√©ussie (donc que le fichier existe et a pu √™tre ouvert).
# Un statut de 1 peut indiquer une incapacit√© √† ouvrir le fichier (Inability to open a file), 
# ce qui se produit s'il n'existe pas ou est inaccessible.
if [ $RC -eq 0 ]; then
    echo "Le data set MVS existe et est accessible."
else
    echo "Le data set MVS n'existe pas ou une erreur d'acc√®s s'est produite (RC=$RC)."
fi
```

### 3. Utilisation de la structure conditionnelle `if`

Quelle que soit la commande utilis√©e pour tester l'existence, vous pouvez int√©grer la v√©rification du statut de sortie (`$?`) dans une structure conditionnelle `if`. Le statut de sortie d'une commande est consid√©r√© comme **vrai** (true) si sa valeur est **0** (succ√®s) et **faux** (false) si elle est **non nulle**.

Vous pouvez utiliser la syntaxe `if command; then ... fi` ou la syntaxe `if [ expression ]; then ... fi`. Si vous utilisez la commande `test` (ou `[ ]`), l'expression renvoie un statut (0 pour vrai, 1 pour faux).

Exemple de structure `if` dans un script shell, utilisant la v√©rification du statut apr√®s l'ex√©cution d'une commande TSO/E :

```sh
# Ex√©cute la commande TSO/E (elle renvoie 0 si elle r√©ussit, non-z√©ro si elle √©choue)
tso "ALLOCATE F(TESTDD) DSN('VOTRE.DATASET.MVS.NAME') SHR" > /dev/null 2>&1

if [ $? -eq 0 ]; then
    # Statut de 0 : Succ√®s de l'allocation (le data set existe)
    echo "Le data set est pr√©sent."
    tso "FREE F(TESTDD)"
elif [ $? -ne 0 ]; then
    # Statut non nul : √âchec de l'allocation (le data set n'existe pas ou autre erreur)
    echo "Le data set est absent ou erreur d'acc√®s."
fi
```

**Note sur `[[...]]` :** La syntaxe double crochet `[[ test_expr ]]` est √©galement support√©e dans le shell z/OS et permet de tester des expressions. Cependant, elle fonctionne sur le statut de sortie de l'expression interne, qui est d√©fini par la commande `test` ou par des op√©rateurs internes au shell, mais elle est surtout pertinente pour les fichiers UNIX ou les comparaisons de cha√Ænes/nombres. Pour interagir avec le syst√®me MVS, il est souvent plus simple d'utiliser `tso`/`tsocmd` et de v√©rifier la valeur de `$?`.







